namespace ExperimentFramework;

internal class ComponentClassEntry
{
    public Type Class { get; set; }
    public string Id { get; set; }
    public ExperimentComponentClass? ActiveComponent { get; set; }
    public string? ActiveComponentName { get; set; }
    public Action<ExperimentComponentClass?> ChangeHandler { get; set; }
    public object? ActiveComponentsSettings { get; set; }
    public ComponentClassEntry(Type className, string id, ExperimentComponentClass? activeComponent, Action<ExperimentComponentClass?> changeHandler, string? activeComponentName, object? activeComponentsSettingsUsed = null)
    {
        Class = className;
        Id = id;
        ActiveComponent = activeComponent;
        ChangeHandler = changeHandler;
        ActiveComponentName = activeComponentName;
        ActiveComponentsSettings = activeComponentsSettingsUsed;
    }
}

public class ExperimentContainer : IDisposable
{
    /// <summary>Available component classes, like `LaserComponent`</summary>
    private readonly List<ComponentClassEntry> ComponentClasses = new();
    /// <summary>A list of possible component class implementations, like `TopticaLaserComponent`</summary>
    private readonly Dictionary<Type, List<Type>> Components = new();

    /// <summary>
    /// Event handler which gets called whenever a component changes.
    /// Arguments: (Type componentClass, string componentClassId, ExperimentComponentClass? newComponent)
    /// </summary>
    public event Action<Type, string, ExperimentComponentClass?> ComponentChanged = delegate { };
    public Action<ExperimentContainer, string, string?, object?>? SettingsSaveHandler = null;
    public Func<ExperimentContainer, string, (string? ActiveComponentName, object? Settings)>? SettingsLoadHandler = null;

    /// <summary>
    /// Adds the component class `T`, like `LaserComponent`.
    /// Optionally, an id can be specified if having multiple slots of the same component class.
    /// </summary>
    /// <typeparam name="T">Component class to be added</typeparam>
    /// <param name="id">An id for the component slot to be added; autogenerated if not specified</param>
    public ExperimentContainer AddComponentClass<T>(string? id = null) where T : ExperimentComponentClass
    {
        var exists = (string id) => ComponentClasses.Any(c => c.Id == id);

        var type = typeof(T);
        if (id == null)
        {
            id = ExperimentComponentClass.GetName(type);
            if (exists(id))
            {
                var i = 2;
                for (; exists(id); i++) ;
                id = $"{id} ({i})";
            }
        }
        else if (exists(id))
        {
            throw new ArgumentException($"Component class {type} with id {id} already exists");
        }
        ComponentClasses.Add(new(type, id, null, delegate { }, null));
        Components[type] = new();
        return this;
    }

    /// <summary>Adds a possible implementation, like `TopticaLaserComponent`</summary>
    public ExperimentContainer AddComponent<T>() where T : ExperimentComponentClass
    {
        var typeToAdd = typeof(T);
        if (Components.Values.Any(types => types.Contains(typeToAdd)))
        {
            throw new ArgumentException($"Component {typeToAdd} has already been added");
        }
        var hasBeenAdded = false;
        foreach (var (componentClass, components) in Components)
        {
            if (typeToAdd.IsAssignableTo(componentClass))
            {
                components.Add(typeToAdd);
                hasBeenAdded = true;
            }
        }
        if (!hasBeenAdded)
        {
            throw new ArgumentException($"Component {typeToAdd} does not match any registered component classes");
        }
        return this;
    }

    /// <summary>Returns the class type and id of all component slots</summary>
    public IEnumerable<(Type Class, string Id)> GetComponentClasses() => ComponentClasses.Select(c => (c.Class, c.Id));
    /// <summary>Returns all possible components which can be used for/implement a specific component class</summary>
    public IEnumerable<(Type Type, string Name, string DisplayName)> GetComponents(Type componentClass) =>
        Components[componentClass].Select(type => (type, type.Name, ExperimentComponentClass.GetName(type)));


    /// <summary>Gets the currently active implementation for the component type `T`</summary>
    public T? GetActiveComponent<T>(string? classId = null) where T : ExperimentComponentClass => (T?)GetActiveComponent(typeof(T), classId);
    /// <summary>Gets the currently active implementation for the component type `T`</summary>
    public ExperimentComponentClass? GetActiveComponent(Type componentClass, string? classId = null)
    {
        var entry = ComponentClasses.FirstOrDefault(c => c.Class == componentClass && (classId == null || c.Id == classId));
        if (entry == null)
        {
            throw new ArgumentException($"Unknown component class {componentClass}{(classId != null ? $" ({classId})" : "")}");
        }
        return entry.ActiveComponent;
    }

    public string? GetActiveComponentName<T>(string? classId = null) where T : ExperimentComponentClass => GetActiveComponentName(typeof(T), classId);
    public string? GetActiveComponentName(Type componentClass, string? classId = null)
    {
        var entry = ComponentClasses.FirstOrDefault(c => c.Class == componentClass && (classId == null || c.Id == classId));
        if (entry == null)
        {
            throw new ArgumentException($"Unknown component class {componentClass}{(classId != null ? $" ({classId})" : "")}");
        }
        return entry.ActiveComponentName;
    }

    public object? GetActiveComponentSettings(Type componentClass, string? classId = null)
    {
        var entry = ComponentClasses.FirstOrDefault(c => c.Class == componentClass && (classId == null || c.Id == classId));
        if (entry == null)
        {
            throw new ArgumentException($"Unknown component class {componentClass}{(classId != null ? $" ({classId})" : "")}");
        }
        return entry.ActiveComponentsSettings;
    }

    /// <summary>
    /// Populates a specific component slot identified by `componentClass` and optionally `classId`
    /// with the component of name `componentName` and the specified settings.
    /// </summary>
    public void ActivateComponent(Type componentClass, string? classId, string? componentName, object? settings = null)
    {
        var entry = ComponentClasses.FirstOrDefault(c => c.Class == componentClass && (classId == null || c.Id == classId));
        if (entry == null)
        {
            throw new ArgumentException($"Unknown component class {componentClass}{(classId != null ? $" ({classId})" : "")}");
        }
        classId = entry.Id;
        entry.ActiveComponent?.Dispose();
        entry.ActiveComponent = null;
        entry.ActiveComponentsSettings = null;
        entry.ActiveComponentName = componentName;

        if (componentName != null)
        {
            var typeOfComponent = GetComponentTypeFromName(componentName) ?? throw new ArgumentException($"Component {componentName} not found");

            var settingsType = ExperimentComponentClass.GetSettingsType(typeOfComponent);
            if (settingsType != null && !(settingsType.IsAssignableFrom(settings?.GetType())))
            {
                throw new ArgumentException($"Settings type {settings?.GetType().Name} is not assignable to {settingsType}");
            }

            try
            {
                var newInstance = (settingsType == null ? Activator.CreateInstance(typeOfComponent) : Activator.CreateInstance(typeOfComponent, settings))
                    as ExperimentComponentClass ?? throw new ArgumentException($"Component {componentName} couldn't be initialized");
                entry.ActiveComponent = newInstance;
            }
            catch { }
        }

        entry.ChangeHandler.Invoke(entry.ActiveComponent);
        ComponentChanged.Invoke(componentClass, classId, entry.ActiveComponent);

        SettingsSaveHandler?.Invoke(this, classId, componentName, settings);
    }

    public void ReloadComponent(Type componentClass, string? classId = null)
    {
        var entry = ComponentClasses.FirstOrDefault(c => c.Class == componentClass && (classId == null || c.Id == classId));
        if (entry == null)
        {
            throw new ArgumentException($"Unknown component class {componentClass}{(classId != null ? $" ({classId})" : "")}");
        }
        ActivateComponent(componentClass, classId, entry.ActiveComponentName, entry.ActiveComponentsSettings);
    }

    /// <summary>Registers an event handler for a specific component class (like `LaserComponent`) being changed</summary>
    public void AddComponentChangeHandler<T>(Action<T?> cb) where T : ExperimentComponentClass => AddComponentChangeHandler<T>(null, cb);
    /// <summary>Registers an event handler for a specific component class (like `LaserComponent`) being changed</summary>
    public void AddComponentChangeHandler<T>(string? classId, Action<T?> cb) where T : ExperimentComponentClass
    {
        var type = typeof(T);
        var entry = ComponentClasses.FirstOrDefault(c => c.Class == type && (classId == null || c.Id == classId));
        if (entry == null)
        {
            throw new ArgumentException($"Unknown component class {type.Name}{(classId != null ? $" ({classId})" : "")}");
        }
        entry.ChangeHandler += (component) => cb((T?)component);
    }

    public Type? GetComponentTypeFromName(string componentName)
    {
        return Components.SelectMany(entry => entry.Value).FirstOrDefault(type => type.Name == componentName);
    }

    /// <summary>Loads the last used active component classes and initializes them with the saved settings</summary>
    public void LoadFromSettings()
    {
        if (SettingsLoadHandler is null)
        {
            throw new Exception("There is no settings store registered.");
        }

        foreach (var entry in ComponentClasses)
        {
            var (componentName, settings) = SettingsLoadHandler(this, entry.Id);
            if (componentName == null)
            {
                continue;
            }
            try
            {
                ActivateComponent(entry.Class, entry.Id, componentName, settings);
            }
            catch { }
        }
    }

    public void Dispose()
    {
        foreach (var entry in ComponentClasses)
        {
            entry.ActiveComponent?.Dispose();
            entry.ActiveComponent = null;
            entry.ActiveComponentsSettings = null;
        }
    }
}
